================================================================================
    Envision Project Overview
=============================================================================


Procedure for creating plug-ins:

Note:  It is very important that all of these steps be followed precisely!!!!

1) In Visual Studio (Debug Win32 configuration), create a new MFC Extension DLL using App Wizard.  The name should be the name of the plug-in,
   the directory should be C:\Envision\src.  AppWizard will create a subdirectory within Envision for the plug-in, it will
   also provide the opportunity to specify the type of MFC dll (make sure to select MFC Extension dll in the Application Settings tab).
   This will create a 32-bit DLL project that needs some additional modifications described below.

   It may be worth verifying that the new project is in C:\Envision\src. If it ended up in c:\Envision, move the whole new directory into C:\Envision\src

2) Modify dllmain.cpp.  
   The next step involves modifying the files generated by the Visual Studio App Wizard.  First, we start
   with the dllmain.cpp file.  Start by replacing the generated dllmain.cpp with the one from the SDK. 
   The replacement file contains default implementations and prototypes for the Envision interface functions. 
   It also contains a number of comments starting with TODO: - these indicate places where you should modify 
   this file, depending on your specific needs.  These basically boil down to: 1) Replacing the “EnvExtExample” 
   string with the name of the DLL you are creating, 2) including/deleting references to the model(s) and/or
    autonomous process(es) you are implementing in the DLL, and commenting out any EMxxx() or APxxx() functions 
    and prototypes you don’t want to use.
    
3) Add exports to myproject.def.
   Add interface export statement to you .def file included in the project.  The simplest way to do this is
   to copy any needed exports out of the EnvExtExample.def file included in the SDK.
    
4) Modify Your Project Settings.
   Right-click on your project in Visual Studio’s Solution Pane and select <Properties>.  This allows you to
   set various project settings.  Change the following, being sure to select <All Configurations>.
   
   Required Project Settings (<All Configurations>)
    1) General->Character Set: Not Set
    2) C/C++ ->General->Additional Include Directories: ..\;..\libs;%(AdditionalIncludeDirectories)    
    3) Linker->General->Additional Library Directories: $(SolutionDir)$(ConfigurationName) 
    4) Linker->Input->Additional Dependencies: libs.lib
    
   For each configuration (Debug and Release):
    1) C/C++ ->Preprocessor->Preprocessor Definitions: add "__EXPORT__=__declspec( dllimport )";  Do not include the quotes!
       
5) Add existing items C:\Envision\src\EnvExtension.cpp and C:\Envision\src\EnvExtension.h to your project

6) After creating a header file for your project, Build your project.  It should be fully buildable at this point.

   
To add an x64 configuration of your plugin:  
1) Bring up Configuration Manager. 
2) Select "x64" for the Solution Platform
3) For your plugin, select "New" from the "Platform" combo box.
4) For both the Release and Debug configurations: In the "New Project Platform" dialog, select 
     a) "x64" from the "Project Platform" combobox,
     b) "Win32" from the "Copy Settings From" combo
     c) make sure the "Create new Solution Platforms" checkbox is OFF    
5) In the project settings, Select the Platform to "x64".  For both the Debug and Release x64 configurations, change:
    Linker->General->Additional Library Directories:  $(SolutionDir)$(PlatformName)\$(ConfigurationName)
    
    
Implementing your model(s) and process(es).
   There are two C++ classes defined in C:\Envision\EnvExtension.h, EnvEvalModel and EnvAutoProcess, to facilitate the creation
   of Envision Plug-ins. They subclass from EnvExtension.  The classes provide several  capabilities:  1) The provide default
   implementations for all interface functions, 2) the manage input and output variables exposed by the models/processes to Envision, 
   and 3) the provide a wrapper to facilitate making changes to the underlying map layers.

To create a model: 
1.	Derive a subclass from EnvEval Model
2.	In the constructor of the class, call EnvExtension::AddVar() for all input and output variables;
3.	Override any of EnvExtension::Init(), InitRun(), Run(), and Setup() as needed.
4.	When accessing the IDU map layer during processes, get the MapLayer pointer from the EnvContext object passed to the DLL; 
    When making changes to the Map, DO NOT call the MapLayer directly;  instead, use EnvExtension::AddDelta() 
    (documented below) to make modifiction to the map.

To create an autonomous process: 
1.	Derive a subclass from EnvAutoProcess
2.	In the constructor of the class, call EnvExtension::AddVar() for all input and output variables;
3.	Override any of EnvExtension::Init(), InitRun(), Run(), ProcessMap(), and Setup() as needed.
4.	When accessing the IDU map layer during processes, get the MapLayer pointer from the EnvContext object passed to the DLL;
    When making changes to the Map, DO NOT call the MapLayer directly;  instead, use EnvExtension::AddDelta() 
    (documented below) to make modifiction to the map.

Implementation Guidelines.

1) The IDU overage is contained in an object of class MapLayer. MapLayer is a class that embodies a single layer of GIS data, 
   and provides numerous GIS operations on that data.  IT also contains a pointer to a Map object that is a container 
   of multiple MapLayers (depending on how many are loaded) and provides for the visual display of the maps.  There are 
   several common tasks involving MapLayer that are described below.

Getting a pointer the IDU MapLayer:  A pointer to the IDU MapLayer is passed in the EnvContext structure during each 
invocation of an interface.  To access this pointer:

const MapLayer *pLayer = pContext->pMapLayer;

To iterate over the IDU coverage:  Use a MapLayer::Iterator as follows

const MapLayer *pLayer = pContext->pMapLayer;

for ( MapLayer::Iterator idu=pLayer->Begin(); idu < pLayer->End(); idu++ )
   {
   float value;  // int, CString, bool, etc.depending on col datatype
   pLayer->GetData( idu, m_colOfInterest, value );
   // do something with the idu’s value of the specified column
   }

To iterate over the DeltaArray:  DeltaArray’s provide a complete history of every change that has been made to the
IDU coverage.  Further, Envision tracks the last time each model/process has “seen” the DeltaArray.  This means that
if a model/process want to see anychanges that have been made either from a particular years, form the beginning of 
the run, or since it was last “seen” by the model/process, that is easily accomplished.

DeltaArray *deltaArray = pContext->deltaArray;// get a ptr to the delta array

// iterate through deltas added since last “seen”
INT_PTR deltaSize = deltaArray.GetSize();  // use static size so you don't process deltas additions from this Run() invocation
for ( INT_PTR i=pContext->firstUnseenDelta; i < deltaSize; ++i )
   {
   DELTA &delta = deltaArray->GetAt(i);
   // do something with the delta
   }
   
To make a modification to the IDU layer:  Models/Processes should not modify the map directly – instead, they should
add a DELTA to the map indicating the change to be made.  Envision then modifies the map with all DELTA’s added when
the model/process returns control to Envision when exiting the call.  The EnvContext contains a pointer to a function 
for adding DELTA’s.  To simplify use, the EnvExtension class provides a member function makes it very easy to add DELTA’s.

const MapLayer *pLayer = pContext->pMapLayer;

for ( MapLayer::Iterator idu=pLayer->Begin(); idu < pLayer->End(); idu++ )
   {
   float fValue = 10.0f;
   int   iValue = 20;   
   AddDelta( pContext, idu, m_col0, fValue ); // note: these are polymorphic
   AddDelta( pContext, idu, m_col1, ivalue );
   }

To define input/output variables for models/processes:  Models can optioanlly expose input and output variables to Envision.
Exposed input variables can be set differently across different scenarios;  exposed output variables are used by Envision 
to collect data from the model/process during a run.  The EnvExtension parent class manages these variables.  All that is 
needed it to indicate the number of each in the constructor, allocate each variable as a class member, and call 
EnvExtension::AddInputVar() or EnvExtension::AddOutputVar() for each variable exposed.

myprocess.h

class MyModel : public EnvEvalModel
{
 protected:
   int m_input1;		// declare input vars
   float m_input2;

   int output;		// declare output var

public:
   MyModel();   		// constructor
}

myprocess.cpp

MyModel::MyModel()
: EnvEvalModel()
, m_input1(10)
, m_input2(2)
, m_output( 5 )
   {
   AddInputVar( _T(“Input 1”), m_input1, _T(“this is an input”) ); 
   AddInputVar( _T(“Input 2”), m_input2, _T(“this is another”) ); 

   AddOutputVar( _T(“Output”), m_output, _T(“this is an output”) ); 
   }
 
